/*

*******************************************************************************
================================================================================
【平    台】stm32f103zet6_sumjess平台
【编    写】sumjess
【E-mail  】1371129880@qq.com
【软件版本】V2.0
【最后更新】2018年09月06日
【相关信息参考下列地址】
【网    站】
           https://blog.csdn.net/qq_38351824
           http://www.openedv.com/
           http://www.stmcu.org/
					 http://www.firebbs.cn/forum.php
---------------------------------------------------------------------------------
【dev.env.】MDK5.14及以上版本
【Target  】stm32f103zet6
第一次修订：2017/11/09
第二次修订：2018/01/21
第三次修订：2018/09/06
【problem 】
    （1）库内补充的不全面；
    （2）库内解释部分不全面；
    （3）库内还存在一定的bug；
【direction】
      下一步的目标就是把库继续集成！
【explain 】
      本库是根据正点原子、中景园电子、优信电子等商家改编而成，
      同时为了方便使用，我也自己写了很多的库，和优化了算法和表示方式！
【warning】
      目前程序中暂无警告 ！   
---------------------------------------------------------------------------------
没有完美的代码，只有不断的奉献，大家一起努力；
赠人玫瑰手留余香，欢迎大家反馈bug！
================================================================================
********************************************************************************



*******************步骤**********************
①使能按键对应IO口时钟。调用函数：
     RCC_APB2PeriphClockCmd();
②初始化IO模式：上拉/下拉输入。调用函数：@@@在其对应的文件中有图文解释@@@
     GPIO_Init();
③扫描IO口电平（库函数/寄存器/位操作）。


******************读取IO*********************
读取IO口输入电平调用库函数为：
uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
读取IO口输入电平操作寄存器为：
GPIOx_1;//按键按松开标志
	if(mode)key_up=1;  //支持连按		  
	if(key_up&&(KEY0==0||KEY1==0||WK_UP==1))//如果按下了
	{IDR:端口输入寄存器：
使用位带操作读取IO口输入电平：
      PEin(4)          -读取GPIOE.4口电平
      PEin(n)          -读取GPIOE.n口电平
			
			
			
**************************扫描程序讲解*************************

u8 KEY_Scan(u8 mode)//令mode==1，支持连续按，令mode==0，不支持连续按
{	 
	static u8 key_up=
		delay_ms(10);//去抖动 
		key_up=0;
		if(KEY0==0)return KEY0_PRES;//此处KEYX_PRES要与.h文件中的定义相匹配
		else if(KEY1==0)return KEY1_PRES;
		else if(WK_UP==1)return WKUP_PRES; 
	}else if(KEY0==1&&KEY1==1&&WK_UP==0)key_up=1; 	     
	return 0;// 无按键按下
}

****************************************************************
************************注意事项*********************************
****************************************************************
***1.不要在主函数中遗漏，变量需要放在开头声明；u8 t=0;延时的初始化也需要写，如果没写，程序不会报错，但是不能达到效果：
****************************************************************
***2.主函数中while（1）的写法:
		t=KEY_Scan(0);		//得到键值
			switch(t)
		{				 
			case KEY0_PRES:
				LED0=!LED0;
				break;
			case KEY1_PRES:
				LED1=!LED1;
				break;
			case WKUP_PRES:				
				LED0=!LED0;
				LED1=!LED1;
				break;
			default:
				delay_ms(10);
			}
***************************************************************

****&&&&&*****&&&&&*****&&&&&***&&&******&&&****&&&&&**&&&&……
特别注意：内设按键和外设按键的读取数值是一样的
内设：GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_5)；
外设：GPIO_ReadOutputDataBit(GPIOA,GPIO_Pin_7)；


简单来讲： GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)读的是GPIOx_IDR,读的是当IO口设置为输入状态时候的IO口值 
          GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)读的是GPIOx_ODR，读的是当IO口设置为输出状态时候的IO口值 


               如果你想详细一点了解这两个函数的区别的话，你可以这样试试，就拿那个按键控制LED灯的实验来说吧， 
           （1）当你设置KEY为上拉输入，你用GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin) 
                去读IO口状态的时候，若你没有按下按键，你读出来的IO值是1，（因为上拉输入把IO口拉高），当你按下按键的时候，你读出来的IO值是0， 
               （因为按下按键把IO拉低） 
 
           （2）当你设置KEY为上拉输入，你用 GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin) 去读IO口状态的时候， 
                 无论你按不按下按键，你读出来的值都是1，因为用GPIO_ReadOutputDataBit去读IO口，它是可以忽略外部操作（按下按键）对它的影响 
                 它只认可内部的操作（上拉电阻的影响）。
        推荐用GPIO_ReadInputDataBit（）；




























*/















